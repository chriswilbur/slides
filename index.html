<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>ðŸš€ Domain Manager</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/dracula.css">
  <link rel="stylesheet" href="fontawesome/css/all.css">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/zenburn.css">
  
  <!-- Custom styling -->
  <style>
    .reveal i.fa {
      font-family: FontAwesome;
      font-style: normal;
    }
  
    /* Fragment blur animation */
    .fragment.blur {
      filter: blur(7px);
    }
  
    .fragment.blur.visible {
      filter: none;
    }
  
    /* External link icon */
    .ext {
      height: 14px;
      padding-left: 4px;
    }
  
    pre code.smaller {
      font-size: 14px;
      line-height: 1.5;
    }
  
    .reveal h4,
    .reveal h5 {
      text-transform: none;
    }
  
    .reveal section pre code {
      font-size: 14px !important;
      line-height: 1.5 !important;
    }
  </style>
  </head>

<body>
  <div class="reveal">
    <div class="slides">
<section> <!-- Title slide -->
  <h2>Domain Manager</h2>
  <p><small>Presented by <a href="mailto:christopher.a.wilbur@lmco.com">Chris Wilbur</a>, <a
        href="mailto:zacharia.alaoui@lmco.com">Zach Alaoui</a>, and <a href="mailto:nathan.novick@lmco.com">Nathan
        Novick</a></small></p>
</section>

<section> <!-- Agenda -->
  <h2>Agenda</h2>
  <ul>
    <li class="fragment fade-in-then-semi-out">WOSA</li>
    <li class="fragment fade-in-then-semi-out">Domain Manager</li>
    <li class="fragment fade-in-then-semi-out">Domain Plugin System</li>
    <li class="fragment fade-in-then-semi-out">Domain Factory</li>
    <li class="fragment fade-in-then-semi-out">Code Walkthrough</li>
    <li class="fragment fade-in-then-semi-out">Resources</li>
  </ul>
</section>

<section> <!-- BEGIN WOSA Section -->
  <section>
    <h2>WOSA</h2>
    <ul>
      <li class="fragment fade-in-then-semi-out">Developed and maintained by Air Force Research Laboratory (AFRL)</li>
      <li class="fragment fade-in-then-semi-out">Defined by <a
          href="https://mfc-conf-prd.us.lmco.com:8443/display/WOSA/WOSA+ICDs" data-preview-link>WOSA Interface Control
          Documents (ICD)</a></li>
      <li class="fragment fade-in-then-semi-out">Framework that enables <strong>Open Architecture</strong></li>
      <li class="fragment fade-in-then-semi-out">Attempts to increase <strong>code reuse</strong></li>
    </ul>

    <aside class="notes">
      <ul>
        <li>What is WOSA and where'd it come from? </li>
        <li>AFRL's attempt to implement OA </li>
        <li>Open Architecture = computer or software architecture created using open standards </li>
        <li>Openness refers to use of interface standards that are freely available </li>
        <ul>
          <li>...think MS Windows and linux vs Apple OS.</li>
        </ul>
        <li>OA is based on open standards that are easy to implement and modify </li>
        <li>simplifies the addition and modification of the various parts of the whole.</li>
        <li>...which leads us to WOSA Domains.</li>
      </ul>
    </aside>
  </section>

  <section> <!-- BEGIN WOSA Domain Section -->
    <h2>WOSA Domains</h2>
    <ul>
      <li class="fragment fade-in-then-semi-out">Modular & Consumable Components</li>
      <li class="fragment fade-in-then-semi-out">Built as stand alone libraries</li>
      <li class="fragment fade-in-then-semi-out">Executables for each Domain</li>
      <li class="fragment fade-in-then-semi-out">Users can link multiple Domains (IFS or OFP)</li>
      <li class="fragment fade-in-then-semi-out">Moving towards an <strong>Open Architecture</strong></li>
    </ul>
    <aside class="notes">
      <ul>
        <li>Modular & Consumable Components : WOSA breaks architecture into logical domains (i.e. MDB, ADS, AFC, GAN,
          IMU)</li>
        <li><small>we'll discuss libaries later</small></li>
        <ul>
          <li>Recall that OA is all about REUSE i.e. simplifying the addition, upgrade, and replacement of the various
            parts/domains</li>
        </ul>
        <li>The point here is that with domains we are increasing our code reuse, modularity and moving towards OA</li>
        <li>... however, we need a way to <strong>manage</strong> all of this modularity</li>
      </ul>
    </aside>
  </section> <!-- END WOSA Domain Section -->

</section> <!-- END WOSA Section -->

<section> <!-- BEGIN Domain Manager Section -->

  <section>
    <h2>Domain Manager</h2>
    <ul>
      <li class="fragment fade-in-then-semi-out">Manages all domains present in the system</li>
      <li class="fragment fade-in-then-semi-out">Configurable via JSON file</li>
      <li class="fragment fade-in-then-semi-out">Uses the <strong>MDBManager</strong> to :</li>
      <ul>
        <li class="fragment fade-in-then-semi-out">Configure & retrieve all MDB Domain Objects for the system</li>
        <li class="fragment fade-in-then-semi-out">Retrieve the applicable MDB Interface slated for each configured
          domain instance </li>
      </ul>
      <li class="fragment fade-in-then-semi-out">Optionally uses the <strong>DynamicPluginManager</strong> to load all
        domain plugins.</li>
    </ul>
    <aside class="notes">
      <ul>
        <li>The domain manager is in charge for managing the domains present in the system.</li>
        <li>It uses the MDB_Manger to manage the different MDB domains in the system</li>
        <li>It uses the Domain Factory to create the desired individual Domains</li>
        <li>Domain Manager is Configurable.</li>
        <li>It uses the <strong>Dynamic_Plugin_Manger</strong> to load all the plugins.</li>
        <ul>
          <li><small><strong>*** Not implemented in the WOSA Framework example **</strong></small></li>
        </ul>
      </ul>
    </aside>
  </section>

  <section> <!-- Begin Plugin System Section-->
    <h2>Domain Plugin System</h2>
    <ul>
      <li class="fragment fade-in">Domains can be implemented as <em>shared libraries</em>
        <ul class="fragment fade-in-then-out">
          <li>Allows exchanging domains without recompiling/relinking</li>
        </ul>
      </li>

      <li class="fragment fade-in">Domain plugins are specified in the Domain Manager <em>config file</em>
        <ul class="fragment fade-in-then-out">
          <li>Stored in a <code>domain_plugins</code> JSON object</li>
        </ul>
      </li>

      <li class="fragment fade-in">The <code>DynamicPluginManager</code> loads domain plugins at <em>runtime</em>
        <ul class="fragment fade-in-then-out">
          <li>Dyanmic linking using <code>.dll</code> or <code>.so</code> files</li>
        </ul>
      </li>

      <li class="fragment">Plugins must adhere to the <a
          href="https://gitlab.us.lmco.com/hub/incubator/mra/modules/arise-msw-utilities/-/blob/develop/src/dynamic-plugin/include/arise/msw/dynamic_plugin_api.h?ref_type=heads">DynamicPluginAPI</a>
      </li>
      <ul class="fragment fade-in-then-out">
        <li>Defines <em>initialization</em> and <em>finalization</em> of a plugin</li>
      </ul>

    </ul>

    <aside class="notes">
      <ul>
        <li>The Domain Plugin System provides resources needed to support dynamically pluggable domain objects by
          utilizing shared libraries</li>
        <li>Domains loaded into the Domain Manager are specified in the config file, either explicitly or as external
          libraries</li>
        <li>When domain plugins are specified in the config file, the DomainManager uses the DynamicPluginManager to
          load them at runtime (dynamic linking),
          rather than statically linking at compile time</li>
        <li>The DynamicPluginAPI describes how to design a domain plugin to be compatible with the Domain Manager</li>
      </ul>
    </aside>
  </section> <!-- End Plugin System Section-->

</section> <!-- End Domain Manager Section -->

<section> <!-- BEGIN Domain Factory Section -->

  <section>
    <h2>Domain Factory</h2>
    <ul>
      <li class="fragment fade-in-then-semi-out">What is the Domain Factory?</li>
      <li class="fragment fade-in-then-semi-out">How does the Domain Factory create domains?</li>
      <li class="fragment fade-in-then-semi-out">What type of design pattern does the Domain Factory use?</li>
      <aside class="notes">
        <ul><small>
            <li>The DomainFactory :</li>
            <ul>
              <li>"is-a" <strong>arise::msw::singleton</strong> class that is used and shared by all processes (plugin
                libraries and the main executable)</li>
              <ul>
                <li>all processes means anything that is running in the software will have access to this one
                  DomainFactory</li>
                <li>"is-a" means that DomainFactory inherits (is a type of, or 'is-a') singleton</li>
                <li>singleton means that there can only be one within the system and it is shared by ALL</li>
              </ul>
              <li>is used to create individual domains with the assistance of the ClassFactory.</li>
              <li>allows external entities to use the factory, and to register with the factory or to create a
                registered derived Domain_Object</li>
              <li>uses the assistance of the Class Factory utility template class</li>

              <li>Possible question if we have time: The Singleton utility was used as opposed to straight statics so
                that it can be properly handled within the IFS (SimulationSingleton)</li>
            </ul>
            <li>The Class Factory :</li>
            <ul>
              <li>allows you to register and unregister the named factory from the map of factory types during runtime.
              </li>
              <li>provides a generic extensible factory for objects with a variable amount of function arguments.</li>
            </ul>
            <li>It uses a singleton design pattern which allows you to create one global Factory.</li>
          </small></ul>
  </section>

  <section>
    <h2>Register Domain</h2>
    <p>main.cpp</p>
    <pre><code class="hljs cpp" data-ln-start-from="189" data-trim data-line-numbers><script type="text/template">
            //The following is to demonstrate that domains can be statically linked
            //and don't have to be compiled as separate loadable library plugins
            //[Note] DomainFactory::Instance() creates a singleton of the DomainFactoryType
            arise::msw::DomainFactory::Instance().RegisterType< IntegrationDomainApp >(
              "Sample Static Domain");
            </script></code></pre>
    <aside class="notes">
      <ul>
        <li>I want to give a brief introduction to this piece of code, which register's a domain</li>
        <li>In this piece of code we create an instance which creates a singleton and it registers a
          IntegrationDomainApp</li>
        <li>And it also passes the domain key which is Sample static Domain.</li>
        <li>*The registerType function returns true if the insertion of the derived type was inserted to our map</li>
      </ul>
    </aside>
  </section>

  <section>
    <h2>Create Domain</h2>
    <p>domain_manager.cpp</p>
    <pre><code class="hljs cpp" data-ln-start-from="158" data-trim data-line-numbers><script type="text/template">
            // All plugins self-register themselves with the Domain Factory. Let's use
            // the Domain_Factory to create the desired individual domains.
            std::shared_ptr< wosa_api::Domain_API > obj(DomainFactory::Instance().Create(
              di_info.registration_key_, domain_identifier, mdb_api, domain_config, nullptr, nullptr));
            </script></code></pre>
    <aside class="notes">
      <ul>
        <li>In this piece of code we have a DOMAIN_API pointer called obj, and we have an instance() of the
          DomainFactory</li>
        <li>We then have a create function which passes the name associated with the factory. </li>
        <li>Here we create all the domains, for the JSON File</li>
        <li>obj grabs the instance that was created in the previous slide, use the create function that grabs the
          IntegrationDomainApp constructor to make a domain</li>
        <li>obj is going to be a pointer to that domain</li>
      </ul>
    </aside>
  </section>

  <section>
    <h4>Domain Factory</h4>
    <pre><code class="hljs cpp" data-ln-start-from="189" data-trim data-line-numbers="|4|"><script type="text/template">
            //The following is to demonstrate that domains can be statically linked
            //and don't have to be compiled as separate loadable library plugins
            //[Note] DomainFactory::Instance() creates a singleton of the DomainFactoryType
            arise::msw::DomainFactory::Instance().RegisterType< IntegrationDomainApp >("Sample Static Domain");
            </script></code></pre>
    <pre><code class="hljs cpp" data-ln-start-from="158" data-trim data-line-numbers="|3-4|"><script type="text/template">
          // All plugins self-register themselves with the Domain Factory. Let's use
          // the Domain_Factory to create the desired individual domains.
          std::shared_ptr< wosa_api::Domain_API > obj(DomainFactory::Instance().Create(
            di_info.registration_key_, domain_identifier, mdb_api, domain_config, nullptr, nullptr));
          </script></code></pre>
    <pre><code class="hljs cpp" data-ln-start-from="115" data-trim data-line-numbers="|1|3|4|6|"><script type="text/template">
            std::unique_ptr< T > Create(std::string name, CArgs... args)
            {
              auto it = funcs_container_.find(name);
              if (it != funcs_container_.end())
              {
                return it->second(std::forward< CArgs >(args)...);
              }
              return nullptr;
            }
          </script></code></pre>
    <aside class="notes">
      <ul>
        <li>Behind the scenes</li>
        <ul>
          <li>in ClassFactory, Create() takes in 2 params: name/key and paramareters group</li>
          <li>and then searches through a DomainFactory's funcs_container_ for the key ("Sample Static Domain")</li>
          <li>if key is found: returns a pointer to the IntegrationDomainApp created</li>
          <li>else return a nullptr</li>
        </ul>
      </ul>
    </aside>
  </section>

</section> <!-- End Domain Factory Section -->

<section> <!-- BEGIN Code Walkthrough Section -->

  <section>
    <h2>Code walk through</h2>
    <ul>
      <li class="fragment fade-in-then-semi-out">JSON Config File</li>
      <li class="fragment fade-in-then-semi-out">MDB Manager</li>
      <li class="fragment fade-in-then-semi-out">Domain Manager</li>
      <li class="fragment fade-in-then-semi-out">Execution</li>
    </ul>
  </section>

  <!-- Parsing of the JSON Config File -->
  <section>
    <p>Parse the JSON Config File</p>
    <pre><code class="hljs cpp" data-ln-start-from="194" data-trim data-line-numbers="|1-2|4-5|7|9-10"><script type="text/template">
            // Set port-driver pointer to parse JSON Config file
            std::shared_ptr< arise::msw::Port > domain_config_file_port = std::make_shared< arise::msw::MultiFileDriver >("Domain config port");

            // Parse Domain Management input file
            arise::msw::DomainConfigInitJSON config_init(domain_config_file_port.get(), input_folder, input_filename);

            if (!config_init.IsDomainMgmtConfigValid())
            {
              std::cout << "Unable to retrieve Domain Mgmt Config File info" << std::endl;
              return -1;
            }
          </script></code></pre>
    <aside class="notes">
      <p>Our exuctable starts with parsing the config file</p>
      <ol>
        <li>Set port/driver pointer </li>
        <li>Create the DomainConfigInitJSON config object and parse the JSON Config file </li>
        <li>verify the validity of the config object </li>
        <li>JSON Poperties : "file_version", "mdb_configuration_filenames", "domain_plugins", "domain_instances",
          "execution_groups" </li>
      </ol>
    </aside>
  </section>

  <section data-markdown="../src/json_config.md"></section>

  <!-- Create and configure the MDB Manager -->
  <section>
    <p>Create and configure the MDB Manager</p>
    <pre><code class="hljs cpp" data-ln-start-from="206" data-trim data-line-numbers="|1-2|4-5"><script type="text/template">
            // Create the concrete MDB Manager
            std::shared_ptr< arise::msw::MDBManager > mdb_manager = std::make_shared< NullMDBManager >();

            // Retrieve the MDB configuration filename(s) and use the MDB Manager to parse it
            std::vector< std::string > const &mdb_config_filenames = config_init.GetMdbConfigFileNames();
            if (!mdb_config_filenames.empty())
            {
              std::shared_ptr< arise::msw::Port > mdb_config_file_port =
                std::make_shared< arise::msw::MultiFileDriver >("MDB config port");
              arise::msw::MDBManager::FilePortsList file_ports_list;
              std::transform(mdb_config_filenames.begin(),
                            mdb_config_filenames.end(),
                            std::back_inserter(file_ports_list),
                            [&](const std::string &file)
                            { return std::make_pair(mdb_config_file_port, file); });
              if (!mdb_manager->Configure(file_ports_list))
              {
                std::cout << "MDB Manager Failed to parse MDB File(s)" << std::endl;
              }
            }
        </script></code></pre>
    <aside class="notes">
      <p>Now that we have the json file parsed and the new config object, we need to create the MDB Manager</p>
      <ol>
        <li>Creates the MDB Manager object.. null for this example </li>
        <li>get MDB Config names </li>
      </ol>
    </aside>
  </section>

  <section>
    <p>getting the MDB config names</p>
    <pre><code class="hljs json" data-ln-start-from="2" data-trim data-line-numbers="2-5 "><script type="text/template">
            "file_version" : "1.0.0",
            "mdb_configuration_filenames" : [
              "not_used_in_this_example_1.json",
              "not_used_in_this_example_2.json"
            ],
            "domain_plugins": [ {} ],
            "domain_instances": [
              { "domain_name": "Sample Domain #1", "domain_id": "0xC4", "instance_id": 1, "element_id": 1,
                "tdp_filename": "../INPUT_DATA/tdp_file_sample_domain.txt",
                "connecting_mdb_instance_id": 1, "connecting_mdb_element_id": 1,
                "factory_registration_key": "Sample Static Domain"
              },
          </script></code></pre>
    <aside class="notes">
      <p>mdb config files are used to configure the MDBs</p>
    </aside>
  </section>

  <section>
    <p>Create and configure the MDB Manager</p>
    <pre><code class="hljs cpp" data-ln-start-from="206" data-trim data-line-numbers="4-5|8-9|10|11-15 "><script type="text/template">
            // Create the concrete MDB Manager
            std::shared_ptr< arise::msw::MDBManager > mdb_manager = std::make_shared< NullMDBManager >();

            // Retrieve the MDB configuration filename(s) and use the MDB Manager to parse it
            std::vector< std::string > const &mdb_config_filenames = config_init.GetMdbConfigFileNames();
            if (!mdb_config_filenames.empty())
            {
              std::shared_ptr< arise::msw::Port > mdb_config_file_port =
                std::make_shared< arise::msw::MultiFileDriver >("MDB config port");
              arise::msw::MDBManager::FilePortsList file_ports_list;
              std::transform(mdb_config_filenames.begin(),
                            mdb_config_filenames.end(),
                            std::back_inserter(file_ports_list),
                            [&](const std::string &file)
                            { return std::make_pair(mdb_config_file_port, file); });
              if (!mdb_manager->Configure(file_ports_list))
              {
                std::cout << "MDB Manager Failed to parse MDB File(s)" << std::endl;
              }
            }
        </script></code></pre>
    <aside class="notes">
      <ol start="3">
        <li>Now that we have the mdb_config_filenames, </li>
        <li>need to get & set port drivers for the MDB and associated domains (MultiFileDriver, for this example)</li>
        <li>transform creates a list of pairs (mdb_config_filenames, file_port)</li>
        <li>then uses that list of pairs to configure the mdb_manager</li>
      </ol>
    </aside>
  </section>

  <!-- Create the Domain Manager -->
  <section>
    <p>Domain Manager - Creation </p>
    <pre><code class="hljs cpp" data-ln-start-from="227" data-trim data-line-numbers="1-2|4-5 "><script type="text/template">
            // Create the Domain Manager
            arise::msw::DomainManager domain_manager(mdb_manager);

            // Initialize the Domain Manager
            domain_manager.Initialize(config_init);
          </script></code></pre>
    <pre><code class="hljs cpp" data-ln-start-from="62" data-trim data-line-numbers><script type="text/template">
            /**
             * @brief DomainManager constructor.
             *
             * @param[in] mdb_mgr is the helper class used for retrieval of MDB
             * interfaces used by Domains and the WOSA MDB domain(s) themselves
             * @param[in] plugin_mgr provides the ability to install dynamic linked
             * domain libraries
             */
            explicit DomainManager(std::shared_ptr< MDBManager > mdb_mgr,
                                   std::shared_ptr< DynamicPluginManager > plugin_mgr = nullptr);
          </script></code></pre>
    <aside class="notes">
      <ul>
        <li>Now that we have MDB Manager configured</li>
        <li>We create an unitialized domain_manager with said MDB_Manger</li>
        <li>Notice that in the second window, the DM constructor sets default plugin mgr to nullptr</li>
        <li>Then, back in the first window, once the domain manager has been created, we initialize it</li>
      </ul>
    </aside>
  </section>

  <section data-markdown="../src/dmn_mgr_Initialize.md"></section>

  <section>
    <p>Domain Manager Using ClassFactory</p>
    <pre><code class="hljs cpp" data-ln-start-from="158" data-trim data-line-numbers><script type="text/template">
            // All plugins self-register themselves with the Domain Factory. Let's use
            // the Domain_Factory to create the desired individual domains.
            std::shared_ptr< wosa_api::Domain_API > obj(DomainFactory::Instance().Create(
              di_info.registration_key_, domain_identifier, mdb_api, domain_config, nullptr, nullptr));
            </script></code></pre>
    <pre><code class="hljs cpp" data-ln-start-from="73" data-trim data-line-numbers><script type="text/template">
            /**
                * @brief The Create function will create an instance based on the named type in the factory
                * @param[in] name is the name associated with the factory
                * @param[in] args is a list of arguments associated with the constructor of the factory typd
                * @retval pointer to the created instance for the class template parameter type if successful
                * @retval nullptr otherwise
                */
              std::unique_ptr< T > Create(std::string name, CArgs... args)
              {
                auto it = funcs_container_.find(name);
                if (it != funcs_container_.end())
                {
                  return it->second(std::forward< CArgs >(args)...);
                }
                return nullptr;
              }
            </script></code></pre>
    <aside class="notes">
      <ul>
        <li>Dmn Mgr calls DomainFactory singleton which is a ClassFactory object.</li>
        <li>Create function in the ClassFactory recieves the string, name, and a list of arguments</li>
        <ul>
          <li>name = di_info.registration_key_ = Sample Static Domain</li>
          <li>and it->second = IntegrationDomainApp constructor function</li>
        </ul>
      </ul>
    </aside>
  </section>

  <section data-markdown="../src/main-IntegrationDomainApp.md"></section>

  <section data-markdown="../src/dmn_mgr_Initialize_2.md"></section>

  <section data-markdown="../src/dmn_mgr_addDomain.md"></section>

  <section data-markdown="../src/dm-Executes.md"></section>

  <section data-markdown="../src/main-executes.md"></section>

  <section>
    <h2>Walkthrough</h2>
    <p><a
        href="https://gitlab.us.lmco.com/-/ide/project/hub/incubator/mra/modules/arise-msw-wosa/edit/develop/-/src/wosa-domain-manager/examples/01-domain-manager/main.cpp"
        data-preview-link>Click to use the GitLab web-based IDE</a></p>
  </section>

</section> <!-- End Code Walkthrough Section -->

<section> <!-- BEGIN External Walkthrough Slide -->
  <h2>GitLab Walkthrough</h2>
  <li><a
      href="https://gitlab.us.lmco.com/-/ide/project/hub/incubator/mra/modules/arise-msw-wosa/edit/develop/-/src/wosa-domain-manager/examples/01-domain-manager/main.cpp"
      data-preview-link>Click to start code walkthrough</a></li>
</section> <!-- END Code External Walkthrough Slide -->

<section>
  <h2>Recap</h2>
  <ul>
    <li class="fragment fade-in-then-semi-out">WOSA</li>
    <li class="fragment fade-in-then-semi-out">Domain Manager</li>
    <li class="fragment fade-in-then-semi-out">Domain Plugin System</li>
    <li class="fragment fade-in-then-semi-out">Domain Factory</li>
    <li class="fragment fade-in-then-semi-out">Code Walkthrough</li>
  </ul>
</section>

<section> <!-- BEGIN References Slide -->
  <h2>References</h2>
  <ul>
    <li><a
        href="https://hub.pages.gitlab.us.lmco.com/incubator/mra/arise-user-guide/products/arise-msw-sk/arise-msw-wosa/arise-msw-wosa-overview.html#id2"
        data-preview-link>Click for more WOSA info on the ARISE HUB</a></li>
  </ul>
</section> <!-- End References Slide -->

<section> <!-- Last slide -->
  <h2>Thank you</h2>
  <p></p>
  <h3 class="fragment fade-in">the end...?</h3>
</section>

</div>
</div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/zoom/zoom.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/search/search.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>

  // Also available as an ES module, see:
  // https://revealjs.com/initialization/
  Reveal.initialize({
      controls: true,
      controlsTutorial: true,
      progress: true,
      center: true,
      hash: true,
      slideNumber: true,

      // The "normal" size of the presentation, aspect ratio will
      // be preserved when the presentation is scaled to fit different
      // resolutions. Can be specified using percentage units.
      width: 1260,
      height: 700,

      // Factor of the display size that should remain empty around the content
      margin: 0.02,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 2.0,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
    });

</script>
  </body>

</html>